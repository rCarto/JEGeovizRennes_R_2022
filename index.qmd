---
format: html 
title: "Faire des cartes avec le logiciel libre R"
subtitle: "Journée d'étude 'La boîte à outils de cartographie et de géovisualisation de données : regards croisés de chercheurs'"
date: 2022-01-06
author:
    - name: Timothée Giraud
      orcid: 0000-0002-1932-3323
      email: timothee.giraud@cnrs.fr
      affiliations:
        - id: 1
          name: RIATE (CNRS)
          url: https://riate.cnrs.fr
lang: fr
toc: true
number-sections: true

execute: 
  cache: false
---

## Introduction

Historique et principes de l'outil utilisé

Fonctionnalités principales

Usages actuels (montrer quelques supers exemples)

Vos usages de cet outil (quelques exemples de vos réalisations)

Préparation des données

Modes de représentations (cartes et graphiques)

Mode d'interactions avec les données

Usages potentiels qu'on a pas eu le temps d'explorer

Bilan personnel de l'outil (forces et limites) dans l'offre actuelle


## Préparation des données


### Téléchargement des données
```{r download}
#| eval: false
dir.create("data-raw")
cov_2022_11 <- "https://www.data.gouv.fr/fr/datasets/r/5d469743-9636-4e84-841c-2ae1111b4009"
cov_2022_10 <- "https://www.data.gouv.fr/fr/datasets/r/80b38046-8166-49fd-bbee-fc0ba9612a88"
cov_2022_09 <- "https://www.data.gouv.fr/fr/datasets/r/513862ee-8e8e-426b-9b67-7a4e39ab253a"
download.file(cov_2022_11, destfile = "data-raw/cov_2022_11.csv")
download.file(cov_2022_10, destfile = "data-raw/cov_2022_10.csv")
download.file(cov_2022_09, destfile = "data-raw/cov_2022_09.csv")
```

### Import des données

```{r import}
#| eval: false
cov_raw_1 <- read.csv(file = "data-raw/cov_2022_09.csv", sep = ";")
cov_raw_2 <- read.csv(file = "data-raw/cov_2022_10.csv", sep = ";")
cov_raw_3 <- read.csv(file = "data-raw/cov_2022_11.csv", sep = ";")

cov_raw <- rbind(cov_raw_1, cov_raw_2, cov_raw_3)
```

```{r realimport}
#| include: false
cov_raw <- readRDS("data/cov.rds")
```



### Découverte du jeu de données

```{r decouverte}
nrow(cov_raw)
ncol(cov_raw)
names(cov_raw)
head(cov_raw, 1)
```




### Nettoyage

Suppression des trajets sans durée ni distance renseignées

```{r clean}
cov <- cov_raw[cov_raw$journey_distance != 0 & 
                 cov_raw$journey_duration != 0, ]
```



## Analyses

### Analyse des durées, distances et vitesses

#### Calcul des indicateurs, gestion des unités de mesure

```{r indicators}
duree <- cov$journey_duration
distance <- cov$journey_distance
library(units)
units(distance) <- "m"
units(duree) <- "min"
distance <- set_units(distance, "km")
duree <- set_units(duree, "h")
vitesse <- distance / duree
```

#### Représentations

```{r table}
summary_table <- data.frame(
  rbind(summary(duree), 
        summary(distance), 
        summary(vitesse)), 
  row.names = c("Durée (h)", "Distance (km)", "Vitesse (km/h)"), 
  check.names = FALSE
)
knitr::kable(summary_table, digits = 1)
```




```{r histograms}
#| fig-show: hold
hist(duree)
hist(distance)
hist(vitesse)
```





```{r plot_dd}
plot(x = distance, y = duree,
     main = "Rapport entre durée et distance des trajets",
     pch = 21, cex = .4, col = "white", bg = "darkred")
```


```{r plot_dv}
plot(x = distance, y = vitesse,
     main = "Rapport entre vitesse et distance des trajets",
     pch = 21, cex = .4, col = "white", bg = "darkblue")
abline(h = 80, lty = 2, lwd = .5)
abline(h = 110, lty = 2, lwd = .5)
```



### Zoom sur la Haute-Garonne

#### Sélection des données

Nous sélectionnons les trajets depuis ou vers la Haute-Garonne (31) de moins de 100 km.

```{r selecta31}
dep <- 31
covdep <- cov[cov$journey_start_department %in% dep & 
                cov$journey_distance <= 100000 &
                cov$journey_duration <= 150, ]
```

#### Calcul des indicateurs, gestion des unités de mesure

```{r indicators31}
duree <- covdep$journey_duration
distance <- covdep$journey_distance
library(units)
units(distance) <- "m"
units(duree) <- "min"
distance <- set_units(distance, "km")
vitesse <- distance / duree
vitesse <- set_units(vitesse, "km/h")
```

#### Représentations

```{r table31}
summary_table <- data.frame(
  rbind(summary(duree), 
        summary(distance), 
        summary(vitesse)), 
  row.names = c("Durée (m)", "Distance (km)", "Vitesse (km/h)"), 
  check.names = FALSE
)
knitr::kable(summary_table, digits = 1)
```




```{r histograms31}
#| fig-show: hold
hist(duree, breaks = seq(0,max(as.numeric(duree))+1,1))
hist(distance, breaks = seq(0,100,1))
hist(vitesse, breaks = seq(0,max(as.numeric(vitesse)+1),1))
```

```{r plot_dd31}
plot(x = distance, y = duree,
     main = "Rapport entre durée et distance des trajets",
     pch = 21, cex = .4, col = "white", bg = "darkred") 
```

```{r plot_dv31}
plot(x = distance, y = vitesse,
     main = "Rapport entre vitesse et distance des trajets",
     pch = 21, cex = .4, col = "white", bg = "darkblue")
```



#### Récupération de trajets théoriques

Nous utilisons le package osrm.

Cette fonction est utile pour demander une grande quantité de routes.  
Elle nécessite d'avoir accès à un serveur OSRM. 

```{r nadapar}
#| eval: false
#| code-fold: true
#| code-summary: "Show the code"
get_routes <- function(x, 
                       srcX = "srcx", srcY = "srcy",
                       dstX = "dstx", dstY = "dsty", 
                       ncl = 5){
  ny <- nrow(x)
  sequence <- unique(c(seq(1, ny, 500), ny + 1))
  lseq <- length(sequence) - 1
  ml <- list()
  for  (i in 1:lseq) {
    ml[[i]] <- x[(sequence[i]):(sequence[i + 1] - 1),
                 c(srcX, srcY, dstX, dstY)]
  }
  cl <- parallel::makeCluster(ncl)
  doParallel::registerDoParallel(cl,)
  roads <- foreach::`%dopar%`(
    foreach::foreach(
      ml = ml,
      .packages = c("osrm", "sf"),
      .combine = rbind,
      .inorder = FALSE
    ),
    {
      l <- vector("list", nrow(ml))
      for( i in seq_along(l)){
        l[[i]] <- osrmRoute(src = ml[i, c(srcX, srcY)], 
                            dst = ml[i, c(dstX, dstY)], 
                            osrm.server = "http://0.0.0.0:5000/",
                            osrm.profile = "car",
                            overview = "full")
      }
      l <- do.call(rbind, l)
      l
    }
  )
  parallel::stopCluster(cl)
  roads
}
```

Pour la réutilisation nous enregistrons les routes

```{r nadagetroads}
#| eval: false
roads <- get_routes(x = covdep, 
                    srcX = "journey_start_lon", 
                    srcY = "journey_start_lat",
                    dstX = "journey_end_lon", 
                    dstY = "journey_end_lat", 
                    ncl = 7)
library(sf)
st_write(obj = roads, 
         dsn = "data/road.gpkg", 
         layer = paste0("road_",dep), 
         append = FALSE)

roads <- st_transform(roads, "EPSG:3857")
library(stplanr)
roads$n <- 1
roads_n <- overline(sl = roads, attrib = "n", ncores = 8)
st_write(obj = roads_n, 
         dsn = "data/road.gpkg", 
         layer = paste0("road_",dep,"_ag"), 
         append = FALSE)

```



#### Nettoyage

```{r importroads}
library(sf)
roads <- st_read(dsn = "data/road.gpkg", layer = paste0("road_",dep))
roads_n <- st_read(dsn = "data/road.gpkg", layer = paste0("road_",dep, "_ag"))
```

#### Comparaison 
```{r graphroadsosrm}
#| fig-width: 5
#| fig-height: 5
units(roads$duration) <- "min" 
units(roads$distance) <- "km" 
plot(duree, round(roads$duration,2), asp = 1, 
     pch = 21, cex = .5, col = "white",
     bg = "darkred", xlim = c(0,100), ylim = c(0,100))
abline(a = 0, b = 1)

plot(distance, roads$distance, asp = 1, 
     pch = 21, cex = .5, col = "white", 
     bg = "darkblue", xlim = c(0,100),
     ylim = c(0,100))
abline(a = 0, b = 1)


```



#### Carto
```{r tlse}
covdep_start <- st_as_sf(covdep, 
                         coords  = c('journey_start_lon', 'journey_start_lat'), 
                         crs = "EPSG:4326", remove = F)
covdep_end <- st_as_sf(covdep, 
                       coords  = c('journey_end_lon', 'journey_end_lat'), 
                       crs = "EPSG:4326", remove = F)

covdep_start <- st_transform(covdep_start, "EPSG:3857")
covdep_end <- st_transform(covdep_end, "EPSG:3857")

# centroids des départs 
city <- tapply(X = covdep$trip_id, 
               INDEX = covdep$journey_start_towngroup, 
               FUN = length) |>
  sort(decreasing = TRUE)|>
  names()|>
  head(1)

zone <- covdep_start |>
  subset(journey_start_towngroup %in% city) |>
  st_geometry() |>
  st_union() |>
  st_centroid() |>
  st_buffer(30000) |>
  st_sf()

```


```{r osmT}
library(maptiles)
osm <- get_tiles(zone, 
                 provider = "Stamen.TerrainBackground", 
                 zoom = 10)
library(terra)
osm_r <- osm |>
  mask(zone) |>
  crop(zone)
```


```{r osmap}
#| fig-width: 7
#| fig-height: 7
library(mapsf)
roads_n_in <- st_intersection(roads_n, st_geometry(zone))
maxv <- max(roads_n_in$n)
credits <- paste0("T. Giraud, 2023\n", 
                  get_credit("Stamen.TerrainBackground"), '\n',
                  "Registre de Preuve de Covoiturage (DGITM) - ", 
                  "Au départ du département, pour moins de 100 km et ",
                  "moins d'1H30, ",
                  "de septembre à novembre 2022")
theme <- mf_theme("green", mar = c(0,0,2,0), 
                  line = 2, cex = 1.8, inner = FALSE, pos = "left")
mf_export(zone, filename = paste0("map", dep, ".png"), 
          width = 700, height = 658, 
          expandBB = c(.05,0,0,0.2), theme = theme)
mf_raster(osm_r, add = T)
mf_map(roads_n_in, 'n', 'prop', leg_pos = "topright", col = "darkgreen",
       leg_title = "Nombre de\ncovoiturages\npar tronçon", leg_frame = T, 
       val_max = maxv)
mf_title(city)
mf_credits(credits, bg = mf_theme()$bg)
mf_map(x = zone, col  = NA, lwd = 15, add = T)
mf_scale(5)
dev.off()

```

![](map31.png){width="700px"}


```{r liss}
library(spatstat)
p <- as.ppp(st_coordinates(covdep_start), 
            W = as.owin(zone))
ds <- density.ppp(p, sigma = 1000, eps = c(100, 100), positive = TRUE)
rasdens <- rast(ds) * 1000 * 1000
crs(rasdens) <- 'EPSG:3857'
v <- values(rasdens)
bks <- mf_get_breaks(v[v>5], nbreaks = 8, breaks = "geom")
bks <- unique(c(0,bks))
cols <- hcl.colors(n = length(bks)-1, "Inferno", rev=F)
library(tanaka)
credits <- paste0("T. Giraud, 2023\n", 
                  "Registre de Preuve de Covoiturage (DGITM)\n", 
                  "Au départ du département, pour moins de 100 km et ",
                  "moins d'1H30, ",
                  "de septembre à novembre 2022")
mf_export(zone, filename = paste0("map", dep, "dens.png"), 
          width = 700, height = 658, 
          expandBB = c(.05,0,0,0.2), theme = theme)
tanaka(rasdens, breaks = bks, col = cols, 
       legend.pos = "n", mask = zone, 
       add = TRUE)
mf_legend(type = "choro", pos = "topright",
          val = bks,pal = cols, 
          title = paste0("Densité de départs\n", 
                         "KDE, sigma=1km\n",
                         "(départs par km2)"),
          val_rnd = 0)
mf_map(roads_n_in, 'n', 'prop', col = "#ffffff50",
       leg_title = "Nombre de\ncovoiturages\npar tronçon", 
       val_max = maxv, leg_pos = "right")
mf_title(city)
mf_credits(credits, bg = mf_theme()$bg)
mf_map(x = zone, col  = NA, lwd = 15, add = T)
mf_scale(5)
dev.off()
```

![](map31dens.png)







```{r utils}
#| cache: false
#| echo: false
knitr::opts_chunk$set(echo = FALSE, eval = FALSE)
```




